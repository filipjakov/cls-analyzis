<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Zone.js Stack Trace Demo</title>
    <script src="https://unpkg.com/zone.js@0.9.1/dist/zone.js"></script>
    <script src="https://unpkg.com/zone.js@0.8.20/dist/long-stack-trace-zone.js"></script>
  </head>

  <body>
    <h1>Stack Trace Demo</h1>

    <button id="button1">Bind Error</button>
    <button id="button2">Cause Error</button>

    <script>
      function main () {
        button1.addEventListener('click', bindSecondButton);
      }

      function bindSecondButton () {
        button2.addEventListener('click', throwError);
      }

      function throwError () {
        throw new Error('ðŸ’©ðŸ’©ðŸ’©!');
      }

      // main()
      Zone.current.fork(
        {
          onHandleError: (parentZoneDelegate, currentZone, targetZone, error) => 
            console.log(error.stack)
        }
      ).fork(Zone.longStackTraceZoneSpec).run(main);

let rootZone = Zone.current;
console.log(rootZone.name); // '<root>'

// We create a new zone by forking an existing zone.
let zoneA = rootZone.fork({ name: 'zoneA' });
console.log(rootZone.name); // 'zoneA'

// Child zone knows about its parent zone. (one way reference)
console.log(zoneA.parent === rootZone); // true

function main() {
  // zones can be entered/exited using the `run or runGuarded or runTask` method only.
  zoneA.run(function fnOuter() {
    // inside the `run` method the Zone.current has been updated
    console.log(Zone.current === zoneA) // true

    // Zones are nested in the same way that stack frames are nested.
    rootZone.run(function fnInner() {
      // There is no reason why a nested stack frame must be a child of parent stack frame zone. 
      // This is how one can "escape" a zone. 
      console.log(Zone.current === rootZone) // true
    });
  });
}

main();

    </script>
  </body>
</html>
